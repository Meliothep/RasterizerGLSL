<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLSL Shader Renderer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            width: 100vh;
            height: 100vh;
            align-content: center;
        }
        
        canvas {
            display: block;
            width: 512px;
            height: 512px;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }
        
        .controls label {
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .controls select, 
        .controls input[type="file"] {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            display: block;
            margin-top: 5px;
        }
        
        .shader-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="loading" id="loading">Loading shader...</div>
    
    <div class="controls" style="display: none;" id="controls">
        <label for="modelSelect">Model:</label>
        <select id="modelSelect">
            <option value="plane" selected>Plane</option>
            <option value="cube">Cube</option>
            <option value="sphere">Sphere</option>
        </select>

        <label for="shaderFile">Load Shader (.glsl):</label>
        <input type="file" id="shaderFile" accept=".glsl">
    </div>
    
    <div class="shader-info" style="display: none;" id="shaderInfo">
        Fragment shader loaded and rendering
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL not supported');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = 512;
            canvas.height = 512;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Vertex shader
        const vertexShaderSource =
`#version 300 es
in vec3 a_position;
in vec3 a_normal;
in vec2 a_texCoord;

uniform mat4 u_modelMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_projectionMatrix;
uniform mat4 u_normalMatrix;

out vec3 v_position;
out vec3 v_normal;
out vec2 v_texCoord;
out vec3 v_worldPosition;

void main() {
    vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);
    v_worldPosition = worldPosition.xyz;
    v_position = a_position;
    v_normal = (u_normalMatrix * vec4(a_normal, 0.0)).xyz;
    v_texCoord = a_texCoord;

    gl_Position = u_projectionMatrix * u_viewMatrix * worldPosition;
}`;

        // Default fragment shader
        let fragmentShaderSource = 
`#version 300 es
precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;

in vec2 v_texCoord;

out vec4 fragColor;

void main() {
    vec2 uv = v_texCoord;
    vec3 color = vec3(
        sin(u_time * 0.001) * 0.5 + 0.5,
        cos(u_time * 0.002) * 0.5 + 0.5,
        sin(u_time * 0.003) * 0.5 + 0.5
    );
    fragColor = vec4(color, 1.0);
}
        `;

        // Shader utilities
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Geometry (plane, cube, sphere)
        function createPlaneGeometry() {
            return {
                positions: [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0],
                normals: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                texCoords: [0, 0, 1, 0, 1, 1, 0, 1],
                indices: [0, 1, 2, 0, 2, 3]
            };
        }

        function createCubeGeometry() {
            const positions = [
                -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
                -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,
                -1,  1, -1, -1,  1,  1,  1,  1,  1,  1,  1, -1,
                -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
                 1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,
                -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1
            ];

            const normals = [
                0,0,1, 0,0,1, 0,0,1, 0,0,1,
                0,0,-1,0,0,-1,0,0,-1,0,0,-1,
                0,1,0, 0,1,0, 0,1,0, 0,1,0,
                0,-1,0,0,-1,0,0,-1,0,0,-1,0,
                1,0,0, 1,0,0, 1,0,0, 1,0,0,
                -1,0,0,-1,0,0,-1,0,0,-1,0,0
            ];

            const texCoords = [
                0,0,1,0,1,1,0,1,
                1,0,1,1,0,1,0,0,
                0,1,0,0,1,0,1,1,
                1,1,0,1,0,0,1,0,
                1,0,1,1,0,1,0,0,
                0,0,1,0,1,1,0,1
            ];

            const indices = [
                0,1,2,0,2,3,
                4,5,6,4,6,7,
                8,9,10,8,10,11,
                12,13,14,12,14,15,
                16,17,18,16,18,19,
                20,21,22,20,22,23
            ];

            return { positions, normals, texCoords, indices };
        }

        function createSphereGeometry(radius = 1, segments = 32, rings = 16) {
            const positions = [], normals = [], texCoords = [], indices = [];
            for (let ring = 0; ring <= rings; ring++) {
                const phi = ring * Math.PI / rings;
                const y = Math.cos(phi) * radius;
                const ringRadius = Math.sin(phi) * radius;

                for (let segment = 0; segment <= segments; segment++) {
                    const theta = segment * 2 * Math.PI / segments;
                    const x = Math.cos(theta) * ringRadius;
                    const z = Math.sin(theta) * ringRadius;

                    positions.push(x, y, z);
                    normals.push(x / radius, y / radius, z / radius);
                    texCoords.push(segment / segments, ring / rings);
                }
            }

            for (let ring = 0; ring < rings; ring++) {
                for (let segment = 0; segment < segments; segment++) {
                    const first = ring * (segments + 1) + segment;
                    const second = first + segments + 1;
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            return { positions, normals, texCoords, indices };
        }

        let program, buffers, attributes, uniforms;
        let currentModel = 'plane';

        // Initialize scene
        function initProgram() {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            program = createProgram(gl, vertexShader, fragmentShader);

            attributes = {
                position: gl.getAttribLocation(program, 'a_position'),
                normal: gl.getAttribLocation(program, 'a_normal'),
                texCoord: gl.getAttribLocation(program, 'a_texCoord')
            };

            uniforms = {
                modelMatrix: gl.getUniformLocation(program, 'u_modelMatrix'),
                viewMatrix: gl.getUniformLocation(program, 'u_viewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'u_projectionMatrix'),
                normalMatrix: gl.getUniformLocation(program, 'u_normalMatrix'),
                time: gl.getUniformLocation(program, 'u_time'),
                resolution: gl.getUniformLocation(program, 'u_resolution')
            };
        }

        function createGeometryBuffers() {
            const geometries = {
                plane: createPlaneGeometry(),
                cube: createCubeGeometry(),
                sphere: createSphereGeometry()
            };

            buffers = {};
            Object.keys(geometries).forEach(name => {
                const geometry = geometries[name];
                buffers[name] = {
                    position: gl.createBuffer(),
                    normal: gl.createBuffer(),
                    texCoord: gl.createBuffer(),
                    index: gl.createBuffer(),
                    indexCount: geometry.indices.length
                };

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].position);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.positions), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].normal);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.normals), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].texCoord);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.texCoords), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers[name].index);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geometry.indices), gl.STATIC_DRAW);
            });
        }

        // File input handler
        document.getElementById('shaderFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                fragmentShaderSource = e.target.result;
                initProgram();
                document.getElementById('shaderInfo').textContent = `Loaded shader: ${file.name}`;
            };
            reader.readAsText(file);
        });

        // Matrices
        function createMatrix4() { return new Float32Array(16); }
        function identity(m) { m.fill(0); m[0]=m[5]=m[10]=m[15]=1; return m; }

        const modelMatrix = createMatrix4();
        const viewMatrix = createMatrix4();
        const projectionMatrix = createMatrix4();
        const normalMatrix = createMatrix4();

        function perspective(matrix, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            matrix.fill(0);
            matrix[0] = f / aspect;
            matrix[5] = f;
            matrix[10] = (far + near) * nf;
            matrix[11] = -1;
            matrix[14] = (2 * far * near) * nf;
            return matrix;
        }

        function lookAt(matrix, eye, center, up) {
            const z0 = eye[0] - center[0];
            const z1 = eye[1] - center[1];
            const z2 = eye[2] - center[2];
            let len = Math.sqrt(z0*z0+z1*z1+z2*z2);
            len = 1 / len;
            const zx = z0*len, zy = z1*len, zz = z2*len;
            const x0 = up[1]*zz - up[2]*zy;
            const x1 = up[2]*zx - up[0]*zz;
            const x2 = up[0]*zy - up[1]*zx;
            len = Math.sqrt(x0*x0 + x1*x1 + x2*x2);
            const xx = x0/len, xy = x1/len, xz = x2/len;
            const yx = zy*xz - zz*xy, yy = zz*xx - zx*xz, yz = zx*xy - zy*xx;

            matrix[0]=xx; matrix[1]=yx; matrix[2]=zx; matrix[3]=0;
            matrix[4]=xy; matrix[5]=yy; matrix[6]=zy; matrix[7]=0;
            matrix[8]=xz; matrix[9]=yz; matrix[10]=zz; matrix[11]=0;
            matrix[12]=-(xx*eye[0]+xy*eye[1]+xz*eye[2]);
            matrix[13]=-(yx*eye[0]+yy*eye[1]+yz*eye[2]);
            matrix[14]=-(zx*eye[0]+zy*eye[1]+zz*eye[2]);
            matrix[15]=1;
            return matrix;
        }

        function rotateY(matrix, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const m = createMatrix4();
            identity(m);
            m[0]=cos; m[2]=sin; m[8]=-sin; m[10]=cos;
            multiplyMatrices(matrix, matrix, m);
            return matrix;
        }

        function multiplyMatrices(out, a, b) {
            const temp = new Float32Array(16);
            for (let i=0;i<4;i++) {
                for (let j=0;j<4;j++) {
                    temp[i*4+j] =
                        a[i*4+0]*b[0*4+j] +
                        a[i*4+1]*b[1*4+j] +
                        a[i*4+2]*b[2*4+j] +
                        a[i*4+3]*b[3*4+j];
                }
            }
            out.set(temp);
            return out;
        }

        // Render loop
        function render() {
            const now = performance.now();

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            if (!program) return;

            gl.useProgram(program);

            identity(modelMatrix);
            if (currentModel === 'cube') {
                rotateY(modelMatrix, now * 0.001);
            }

            lookAt(viewMatrix, [0, 0, 3], [0, 0, 0], [0, 1, 0]);
            perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
            identity(normalMatrix);

            if (uniforms.modelMatrix) gl.uniformMatrix4fv(uniforms.modelMatrix, false, modelMatrix);
            if (uniforms.viewMatrix) gl.uniformMatrix4fv(uniforms.viewMatrix, false, viewMatrix);
            if (uniforms.projectionMatrix) gl.uniformMatrix4fv(uniforms.projectionMatrix, false, projectionMatrix);
            if (uniforms.normalMatrix) gl.uniformMatrix4fv(uniforms.normalMatrix, false, normalMatrix);
            if (uniforms.time) gl.uniform1f(uniforms.time, now);
            if (uniforms.resolution) gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);

            const buffer = buffers[currentModel];

            if (attributes.position !== -1) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position);
                gl.vertexAttribPointer(attributes.position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(attributes.position);
            }

            if (attributes.normal !== -1) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer.normal);
                gl.vertexAttribPointer(attributes.normal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(attributes.normal);
            }

            if (attributes.texCoord !== -1) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer.texCoord);
                gl.vertexAttribPointer(attributes.texCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(attributes.texCoord);
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.index);
            gl.drawElements(gl.TRIANGLES, buffer.indexCount, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        // Initialization
        document.getElementById('modelSelect').addEventListener('change', function(e) {
            currentModel = e.target.value;
        });

        createGeometryBuffers();
        initProgram();

        document.getElementById('loading').style.display = 'none';
        document.getElementById('controls').style.display = 'block';
        document.getElementById('shaderInfo').style.display = 'block';

        render();
    </script>
</body>
</html>
